--- spectro/colorhug.c.old	2013-05-24 10:25:59.725611150 +0100
+++ spectro/colorhug.c	2013-05-16 09:44:20.000000000 +0100
@@ -157,7 +157,7 @@ colorhug_command(colorhug *p,
 	int i;
 	unsigned char buf[64];
 	int xwbytes, wbytes;
-	int xrbytes, rbytes;
+	int xrbytes, xrbytes2, rbytes;
 	int se, ua = 0, rv = inst_ok;
 	int ishid = p->icom->port_type(p->icom) == icomt_hid;
 
@@ -199,14 +200,15 @@ colorhug_command(colorhug *p,
 	a1logd(p->log,6,"colorhug_command: Reading response\n");
 
 	if (ishid) {
-		xrbytes = 64;
+		xrbytes = xrbytes2 = 64;
 		se = p->icom->hid_read(p->icom, buf, xrbytes, &rbytes, timeout);
 	} else {
-//		xrbytes = out_size + 2;
 		xrbytes = 64;
+		xrbytes2 = out_size + 2;	/* For backwards compatibility with fw <= 1.1.8 */
 		se = p->icom->usb_read(p->icom, NULL, 0x81, buf, xrbytes, &rbytes, timeout);
 	}
 
+	a1logd(p->log,8,"colorhug_command: Read %d bytes and %d read\n",xrbytes,rbytes);
 	if (rbytes >= 2) {
 		a1logd(p->log,6,"colorhug_command: recieved cmd '%s' error '%s' args '%s'\n",
 				inst_desc(buf[1]),
@@ -225,15 +226,18 @@ colorhug_command(colorhug *p,
 		}
 
 		/* deal with underrun or overrun */
-		if (rbytes != xrbytes) {
+		if (rbytes != xrbytes
+		 && rbytes != xrbytes2) {
 			a1logd(p->log,1,"colorhug_command: got underrun or overrun\n");
 			rv = colorhug_interp_code((inst *)p, COLORHUG_BAD_RD_LENGTH);
 			return rv;
 		}
 
-		/* there's another reason it failed */
-		a1logd(p->log,1,"colorhug_command: read failed with ICOM err 0x%x\n",se);
-		return colorhug_interp_code((inst *)p, COLORHUG_COMS_FAIL);
+		if (se != ICOM_SHORT) {		/* Allow short read for firware compatibility */
+			/* there's another reason it failed */
+			a1logd(p->log,1,"colorhug_command: read failed with ICOM err 0x%x\n",se);
+			return colorhug_interp_code((inst *)p, COLORHUG_COMS_FAIL);
+		}
 	}
 	rv = colorhug_interp_code((inst *)p, icoms2colorhug_err(ua));
 
